---
layout: post
title: android NDK

---

### ANDROID NDK

&emsp;&emsp;熟悉android的朋友都知道，android执行所有代码都是在虚拟机上完成的，如果想要执行一些比较低等的操作，在Linux系统上执行C/C++代码，需要通过Java调用JNI的方式来完成，下面我就来介绍一下Java调用C代码的过程。这篇文章讲分别介绍一下使用eclipse和android studio分别怎么使用。


### 调用过程

&emsp;&emsp;不管采用哪种方式，原理都是一样的，只是过程略有不同，不用的IDE提供了不同的功能，方便大家使用，可能忽略了其中的某些过程，大家要明白只是IDE帮我们做了这些工作，但是具体的步骤大家一定要清楚，首先我先介绍一下原理。

	1.在Java中声明本地方法（native）。
	2.通过JavaH命令编译class文件，生成C/C++的H类型的头文件。
	3.编写C/C++实现文件。
	4.编译成so文件。
	5.把so文件放到Android项目中的libs/armeabi目录中。
	6.根据编译so文件时定义的名字，在Java中通过System.loadLibrar()调用。
	
#### 首先搭建环境

&emsp;&emsp;我的开发环境时Mac OS 相对来说要简单一些，使用windows环境的朋友需要安装Cygwin。这方面我就不介绍了，有需要的朋友自行Google。

1.下载NDK

	https://developer.android.com/intl/zh-cn/ndk/downloads/index.html 

2.安装

	On Linux and Mac OS X (Darwin):
	
		1.Download the appropriate package from this page.
		
		2.Open a terminal window.
		
		3.Go to the directory to which you downloaded the package.
		
		4.Run chmod a+x on the downloaded package.
		
		5.Execute the package. For example:
		
			ndk$ chmod a+x android-ndk-r10c-darwin-x86_64.bin
			ndk$ ./android-ndk-r10c-darwin-x86_64.bin
          
	The folder containing the NDK extracts itself.
	You can also use a program like 7z to extract the package.

3.配置环境变量

&emsp;&emsp;默认情况下在Mac中配置当前用户的环境变量即可，在 ~/.bash_profile ，如果使用的是zsh 环境变量配置在 ~/.zshrc,在环境变量中增加。

	NDK_HOME=/Users/zhaoyang/Developer/tools/android-ndk-r10e
	export PATH=$NDK_HOME:$PATH
	
4.安装和配置完成环境变量后可以在命令行中执行ndk-build,如果你输出内容跟我一样，说明你安装成功了。

	➜  ~  ndk-build
	Android NDK: Could not find application project directory !
	Android NDK: Please define the NDK_PROJECT_PATH variable to point to it.
	/Users/zhaoyang/Developer/tools/android-ndk-r10e/build/core/build-local.mk:143: *** 	Android NDK: Aborting    .  Stop.

5.如果使用IDE执行编译so文件操作的话，我觉得应该是不需要配置环境变量，只需要执行前两部就行了 ，因为我之后会介绍使用命令行的方式，所以需要配置环境变量。
	


#### 首先介绍一下在Eclipse中实现

&emsp;&emsp;eclipse默认的ADT插件中是有NDK配置的，我之前有印象用过，但是我这个最新版本其中没有NKD的选项了，在项目中点击android tools也没有生成H文件的选项了，所以只能通过命令行的自己手动完成，这样也好，可以加深印象，并且对过程有一个更深入的了了解。

1.首先还是在Java代码中完成本地方法的声明。

	package com.example.androidtest;

	public class MathKit {

		public static native int square(int num);

		static {
			System.loadLibrary("JniDemo");
		}

	}

2.跳转到class目录中，在包跟节点执行JavaH命令，生成C的头文件

	javah com.example.androidtest.MathKit
	
3.生成的头文件如下

	/* DO NOT EDIT THIS FILE - it is machine generated */
	#include <jni.h>
	/* Header for class com_example_androidtest_MathKit */

	#ifndef _Included_com_example_androidtest_MathKit
	#define _Included_com_example_androidtest_MathKit
	#ifdef __cplusplus
	extern "C" {
	#endif
	/*
	 * Class:     com_example_androidtest_MathKit
	 * Method:    square
 	* Signature: (I)I
 	*/
	JNIEXPORT jint JNICALL Java_com_example_androidtest_MathKit_square
  	(JNIEnv *, jclass, jint);

	#ifdef __cplusplus
	}
	#endif
	#endif

4.编写C实现文件，内容可以随便写，我就是随便写了一个 传递过来的参数＊5，方法中前两个参数是默认的，第三个参数是根据你Java中定义的native方法中参数决定的。

	#include "com_example_androidtest_MathKit.h"

	JNIEXPORT jint JNICALL Java_com_example_androidtest_MathKit_square(JNIEnv * env,
		jclass jc, jint num) {

		return num * 5;

	}

5.编写Android.文件

	LOCAL_PATH := $(call my-dir)  
   
	include $(CLEAR_VARS)  
   
	LOCAL_LDLIBS := -llog  
	LOCAL_MODULE    := JniDemo
	LOCAL_SRC_FILES := com_example_androidtest_MathKit.c  
   
	include $(BUILD_SHARED_LIBRARY)  
	
	其中有一些参数有兴趣的朋友可以去网上查查，最重要的就是两个：
	
	1 LOCAL_MODULE    := JniDemo
	
	这个JniDemo是决定在Java中通过System.loadLibrary("JniDemo")调用的时候需要写的名字。
	
	2 LOCAL_SRC_FILES := com_example_androidtest_MathKit.c  
	
	这个文件时自己实现的C代码的名字
	
	需要通过这两个文件才可以编译os文件
	
6.编写Application.mk

	我在网上查找资料说，需要这个文件，具体是做什么用的，我没仔细看，总之我没写也没啥问题。

7.在Eclipse项目中根目录新建文件夹jni。

	然后拷贝Android.mk, .h , .c这三个文件到该目录中。
	
8.编译so文件

	在项目的根目录中执行 ndk-build
	
	➜  androidtest  ndk-build
	[armeabi] Install        : libJniDemo.so => libs/armeabi/libJniDemo.so
	
	第一次执行应该会有其他信息，我这是为了演示第二次执行了，总之最后会提示生成了libs/armeabi/libJniDemo.so文件，说明成功了。
	
	这个时候你应该可以看到根部目录中新增了一个libs文件夹
	
9.Java中加在so文件
	
	static {
		System.loadLibrary("JniDemo");
	}
	
10.在代码调用

	MathKit mk = new MathKit();
	Log.i("yangzhao", "==============" + mk.square(6));
	
	
至此在Eclipse中调用就写完了，应该说还是很简单的，如果你使用ADT中的工具，可以简化其中的几个步骤，但是具体的原理是相同的。



#### 在Android Studio中使用

Adnroid Studio中使用可以分为两种方式，一种是如果有so文件，直接放在指定目录中调用即可。另外一种是血C/C++源码，编译SO文件的方式。本文介绍的是第二种C源码的方式。

1.首先还是在Java代码中完成本地方法的声明。

	package com.example.zhaoyang.androidtest;

	/**
 	* Created by zhaoyang on 15/7/14.
 	*/
	public class MathKit {

    public static native int  square(int num);

    	static{
        	System.loadLibrary("JniDemo");
   	 	}
	}

	
2.在local.proerties中配置NDK路径

	在项目的根路径中找到local.properties文件

	ndk.dir=~/Developer/tools/android-ndk-r10e
	
3.生成头文件

	在android studio的terminal工具中，或者命令行到项目根目录中执行
	
	javah -d jni -classpath ~/Developer/tools/android_sdk/platforms/android-19/	android.jar:../../build/intermediates/classes/debug/ 	com.example.zhaoyang.androidtest.MathKit
	
	-d 输出目录，jni是gradle默认的路径    
	-classpath jar的路径，经常碰到的找不到activity的类的错误一般是由这个引起的  
	com.example.zhaoyang.androidtest.MathKit 包名＋文件名
	
＊ 注意在执行这个命令之前要先执行一下Android Studio编译命令，可以在菜单中执行，也可以用快捷键 cmd+b，因为AS跟Eclipse不一样，不是自动编译，没有CLASS文件，而JavaH命令是需要根据CLASS文件来生成C的头文件的。


执行完以上命令系统会在src/main目录中生成jni目录

4.实现C文件，根据接口的方法名来实现，和在Eclipse中一样，就不多做介绍了。

	#include "com_example_zhaoyang_androidtest_mathKit.h"

	JNIEXPORT jint JNICALL Java_com_example_zhaoyang_androidtest_MathKit_square
  	(JNIEnv * env, jclass  obj, jint num){

    	return num * 5;
  	}
  	
5.在build.gradle中新增配置

	在defaultConfig中最后新添加
	
	ndk {
        moduleName "JniDemo"
   		abiFilters "armeabi", "armeabi-v7a", "x86"
    }
    
    moduleName的名字类似于Android.mk中配置的调用名称，通过这个名字可以在Java中使用System.loadLibrary("JniDemo")调用。
    abiFilters 是定义需要编译的环境。
    
    我只是配置了这两项就够用了。
    
6.运行Android项目

	在代码中嗲用这native的方法，然后运行该项目。

	首先你会看到同样是在src/main目录中声称了libs/armeabi/libjniDemo.so文件，然后应该可以实现你想要的效果了。
   
   
   
   
### 总结

&emsp;&emsp;基本上Android通过JNI的方式调用C代码就介绍完了，功能很简单，只是为了给大家演示一下怎么调用，各位可以根据自己的业务需要来实现响应的代码内容。不管是通过工具还是通过命令行来实现，基本上的原理是一样的，还有一些具体的参数，我没有认真研究。<br>
&emsp;&emsp;之前为了完成一个统计卸载的功能，我有写过一次NDK的调用，当时的需求是用户卸载了软件需要统计一下次数,我尝试了很多种方式，比如监听安装包卸载的广播之类的方式，最后发现卸载的速度太快了，根本来不及请求服务器，最后实现的方式是用C监控当前APK安装的目录，如果发现文件被删除了，就打开浏览器，跳转到一个用户反馈的网页，通过记录网页的访问次数的方式，来实现统计删除用户数。<br>
&emsp;&emsp;现在我准备要有一个需求，有的时候我们需要在后台长期运行一个service,并且不能被杀死，或者说杀死以后可以马上启动，通常提高service存活率有几个方式，要么就android:priority="1000"设置高的优先级，要么就是监听各种系统中经常触发的广播，通过这个方式来启动service，要么就把service置成前置通知的方式，但是这些方法试过以后，依然有可能service还是不能启动。通过C的代码监听service，如果service被kill，马上启动service，在网上看到资料可以实现，稍后如果成功，我会整理一篇文章来跟大家分享。<br>

&emsp;&emsp;最后谢谢大家！




   
   
   
       